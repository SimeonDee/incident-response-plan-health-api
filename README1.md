# Incident Response Plan Health — Backend

This repository contains a FastAPI-based backend that manages incident records for an incidence response plan in healthcare contexts. The API provides full CRUD operations for an `Incident` resource and is implemented with SQLAlchemy and Pydantic.

This README documents how to set up, configure, run, and develop the backend. It also documents the available API endpoints, data models, and notes about switching between local SQLite and production MySQL databases.

## Table of contents

- Features
- Technology stack 
- Repository layout
- Quick start (local — SQLite)
- Production / MySQL setup
- Configuration (.env)
- API reference (endpoints + request/response examples)
- Data model
- Development & testing
- Database migrations (Alembic)
- Test scripts & collections
- Development commands (Makefile)
- Contributing
- License & contact

## Features

- RESTful API for incident management (create, read, update, delete)
- Input validation and serialization with Pydantic
- SQLAlchemy ORM models and easy DB configuration
- OpenAPI/Swagger docs auto-generated by FastAPI
- CORS enabled for API access from web UIs
- Database migrations with Alembic
- Comprehensive test suite and tools

## Technology stack

- Python 3.10+ (3.12 supported with compatible packages)
- FastAPI
- SQLAlchemy
- Pydantic
- SQLite (default for local development) or MySQL for production
- Uvicorn as the ASGI server
- Alembic for database migrations
- HTTPie and Postman for API testing

## Repository layout

```
backend/
├── README.md                # This file
├── Makefile                # Development commands
├── alembic.ini             # Alembic migrations config
├── alembic/                # Migration scripts
├── .env                     # Environment variables (not checked into VCS)
├── requirements.txt         # Python dependencies
├── main.py                  # Application entrypoint (starts FastAPI app)
├── init_db.py               # Helper to create MySQL database if needed
├── tests/                  # Test scripts
│   └── test_api.py         # API smoke tests using httpx
├── httpie_examples.sh      # HTTPie command examples
├── postman_collection.json # Postman collection for API testing
├── app/
│   ├── database.py          # SQLAlchemy engine, Session, Base
│   ├── models.py            # SQLAlchemy models (Incident)
│   ├── schemas.py           # Pydantic request/response schemas
│   └── routes.py            # API router that implements CRUD endpoints
├── instance/                # Instance-specific configs (kept for structure)
└── ...
```

## Quick start — local development (SQLite)

Use SQLite for fast local development (no external DB server required).

1. Create and activate a virtual environment (recommended):

```bash
python -m venv .venv
source .venv/bin/activate
```

2. Install Python dependencies:

```bash
pip install -r requirements.txt
```

3. Ensure `app/database.py` is configured to use SQLite (default local config uses SQLite). If you previously changed it for MySQL, you can revert DATABASE_URL to:

```py
DATABASE_URL = "sqlite:///./incidents.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
```

4. Run database migrations:

```bash
make migrate
# or
alembic upgrade head
```

5. Start the server:

```bash
make start
# or
python main.py
```

6. Open the interactive API docs at `http://localhost:8000/docs`.

## Production / MySQL setup

For production or staging you may want to run MySQL (or another managed DB).

1. Install and run MySQL on your host or use a managed provider.

2. Add DB credentials to `.env` (see the Configuration section below).

3. Install the dependencies (use the same `requirements.txt`). I recommend using `mysql-connector-python` or `PyMySQL` depending on your platform. If you choose `mysqlclient` you must also install the MySQL client dev libraries on the host.

4. Initialize the database and run migrations:

```bash
make init-db     # Creates the database if needed
make migrate     # Runs all pending migrations
```

5. Start the server with MySQL configuration.

# Incident Response Plan Health — Backend

This repository contains a FastAPI-based backend that manages incident records for an incidence response plan in healthcare contexts. The API provides full CRUD operations for an `Incident` resource and is implemented with SQLAlchemy and Pydantic.

This README documents how to set up, configure, run, and develop the backend. It also documents the available API endpoints, data models, and notes about switching between local SQLite and production MySQL databases.

## Table of contents

- Features
- Technology stack
- Repository layout
- Quick start (local — SQLite)
- Production / MySQL setup
- Configuration (.env)
- API reference (endpoints + request/response examples)
- Data model
- Development & testing
- Database migrations
- Contributing
- License & contact

## Features

- RESTful API for incident management (create, read, update, delete)
- Input validation and serialization with Pydantic
- SQLAlchemy ORM models and easy DB configuration
- OpenAPI/Swagger docs auto-generated by FastAPI
- CORS enabled for API access from web UIs

## Technology stack

- Python 3.10+ (3.12 supported with compatible packages)
- FastAPI
- SQLAlchemy
- Pydantic
- SQLite (default for local development) or MySQL for production
- Uvicorn as the ASGI server

## Repository layout

```
backend/
├── README.md                # This file
├── .env                     # Environment variables (not checked into VCS)
├── requirements.txt         # Python dependencies
├── main.py                  # Application entrypoint (starts FastAPI app)
├── init_db.py               # Helper to create MySQL database if needed
├── app/
│   ├── database.py          # SQLAlchemy engine, Session, Base
│   ├── models.py            # SQLAlchemy models (Incident)
│   ├── schemas.py           # Pydantic request/response schemas
│   └── routes.py            # API router that implements CRUD endpoints
├── instance/                # Instance-specific configs (kept for structure)
└── ...
```

## Quick start — local development (SQLite)

Use SQLite for fast local development (no external DB server required).

1. Create and activate a virtual environment (recommended):

```bash
python -m venv .venv
source .venv/bin/activate
```

2. Install Python dependencies:

```bash
pip install -r requirements.txt
```

3. Ensure `app/database.py` is configured to use SQLite (default local config uses SQLite). If you previously changed it for MySQL, you can revert DATABASE_URL to:

```py
DATABASE_URL = "sqlite:///./incidents.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
```

4. Start the server (this will create the SQLite file and tables automatically):

```bash
python main.py
```

5. Open the interactive API docs at `http://localhost:8000/docs`.

## Production / MySQL setup

For production or staging you may want to run MySQL (or another managed DB).

1. Install and run MySQL on your host or use a managed provider.

2. Add DB credentials to `.env` (see the Configuration section below).

3. Install the dependencies (use the same `requirements.txt`). I recommend using `mysql-connector-python` or `PyMySQL` depending on your platform. If you choose `mysqlclient` you must also install the MySQL client dev libraries on the host.

## Configuration (.env)

Create a `.env` file in the project root (never commit this to version control).

Required variables for MySQL:
```
MYSQL_HOST=localhost
MYSQL_USER=your_user
MYSQL_PASSWORD=your_password
MYSQL_DATABASE=incidents_db
```

Optional configuration:
```
HOST=0.0.0.0        # Server bind address
PORT=8000           # Server port
```

## API Reference

All endpoints are prefixed with `/api/v1`.

### Incidents

#### Create incident
- `POST /incidents/`
  - Request: Incident details (type, description, location)
  - Response: Created incident object

#### List incidents
- `GET /incidents/`
  - Parameters:
    - skip (int, default=0): Records to skip
    - limit (int, default=100): Max records to return
  - Response: Array of incidents

#### Get incident
- `GET /incidents/{incident_id}`
  - Parameters:
    - incident_id (int): ID of incident
  - Response: Single incident object

#### Update incident
- `PUT /incidents/{incident_id}`
  - Parameters:
    - incident_id (int): ID of incident
  - Request: Updated incident details
  - Response: Updated incident object

#### Delete incident
- `DELETE /incidents/{incident_id}`
  - Parameters:
    - incident_id (int): ID of incident
  - Response: Success message

See the Postman collection or HTTPie examples for request/response samples.

## Data Model

### Incident

SQLAlchemy model (`app/models.py`):
```python
class Incident(Base):
    __tablename__ = "incidents"

    id = Column(Integer, primary_key=True, index=True)
    type = Column(String(50), nullable=False)
    description = Column(String(500))
    location = Column(String(100))
    status = Column(String(20), default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

## Development & testing

### Running tests

The project includes several testing tools:

1. API smoke tests (uses httpx):
```bash
python tests/test_api.py
# or
make test
```

2. HTTPie examples (CLI-based testing):
```bash
chmod +x httpie_examples.sh
./httpie_examples.sh
```

3. Postman collection:
- Import `postman_collection.json` into Postman
- Contains example requests for key endpoints

### Development workflow

1. Create a feature branch
2. Make changes
3. Run tests: `make test`
4. Run migrations if needed: `make migrate`
5. Open a PR

### Development commands (Makefile)

The project includes a Makefile with common commands:

```bash
make start           # Start the FastAPI server
make init-db         # Initialize the database (MySQL)
make migrate         # Run pending migrations
make makemigrations  # Create a new migration
make test           # Run API smoke tests
```

See the Makefile for details on each command.

## Database migrations

The project uses Alembic for database migrations. Migration files are in the `alembic/` directory.

### Running migrations

1. Ensure your database is running and `.env` has correct credentials

2. Apply all migrations:
```bash
make migrate
# or
alembic upgrade head  # applies all pending migrations
```

3. To create a new migration (after changing models):
```bash
make makemigrations
# or
alembic revision --autogenerate -m "describe your changes"
```

### First-time setup

If you have existing tables (created by `Base.metadata.create_all()`), you can start using Alembic without applying the initial migration:

```bash
alembic stamp head  # marks existing tables as migrated
```

Then create new migrations for future schema changes.

### Migration files

- `alembic/versions/0001_initial.py` - Creates the incidents table
- Future migrations will be added here when you run `make makemigrations`

The migration system uses your SQLAlchemy models from `app/models.py` to detect schema changes.

## Security considerations

- Never commit `.env` or secrets to version control.
- Use secure password storage (secrets manager) in production.
- Limit DB user privileges to only what the app requires.

## Contributing

1. Fork the repository
2. Create a branch: `git checkout -b feature/your-feature`
3. Commit your changes and push
4. Open a pull request

Please include tests for new functionality and update README / docs when adding breaking changes.

## License

This project is provided under the MIT License. See the `LICENSE` file for details.

## Contact

- contact here

---

If you'd like, I can also:

- Add an Alembic configuration and an initial migration file.
- Add a short Postman/HTTPie collection and a small test script exercising the CRUD endpoints.
- Add a developer Makefile with common commands (start, init-db, migrate, test).
